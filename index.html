
<!doctype html><html lang="en"><head><meta charset="utf-8"/><link rel="icon" href="./favicon_circle.svg"/><meta name="viewport" content="width=device-width,initial-scale=1"/><meta name="theme-color" content="#ffffff"/><title>s&#8202;l&#8202;o&#8202;w&nbsp;&nbsp;r&#8202;o&#8202;a&#8202;d&#8202;s</title><meta name="title" content="s l o w  r o a d s"><meta name="description" content="endless driving zen in your browser"><meta property="og:type" content="website"><meta property="og:url" content="https://slowroads.io/"><meta property="og:title" content="s l o w  r o a d s"><meta property="og:description" content="endless driving zen in your browser"><meta property="og:image" content="./img.jpg"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://slowroads.io/"><meta property="twitter:title" content="s l o w  r o a d s"><meta property="twitter:description" content="endless driving zen in your browser"><meta property="twitter:image" content="./img.jpg"><link rel="manifest" href="./manifest.json"/><script src="./alea.min.js"></script><link href="./static/css/main.8b77de6a.chunk.css" rel="stylesheet"></head><body>
  <script>
/*
  Amplified mode runtime patch for built app
  - Adds <option value="amplified">Amplified (ultra)</option> to any select in #root
  - When selected, wraps height accessors (getXZ/getHeight/getHeightAt/heightmap arrays)
    to apply a contrast amplification function to terrain heights.
  - Non-destructive: restores originals if you reload the page.
*/

(function () {
  // configurable amplification (3.0 = "ultra")
  const AMPLIFICATION = 3.0;

  // amplification transform (keeps [0,1] range, emphasizes highs/lows)
  function amplifyValue(h) {
    if (typeof h !== "number" || isNaN(h)) return h;
    let v = 0.5 + (h - 0.5) * AMPLIFICATION;
    if (v < 0.5) v = 0.5 - Math.pow(0.5 - v, 0.9);
    else v = 0.5 + Math.pow(v - 0.5, 0.8);
    if (v < 0) v = 0;
    if (v > 1) v = 1;
    return v;
  }

  // add option to any select rendered under #root
  function addAmplifiedOptionToSelect(select) {
    if (!select) return;
    try {
      // avoid duplicates
      for (let opt of select.options) {
        if (opt && opt.value === "amplified") return;
      }
      const opt = document.createElement("option");
      opt.value = "amplified";
      opt.textContent = "Amplified (ultra)";
      // append last so it shows up for users
      select.appendChild(opt);

      // when user selects amplified, set global flag (read by our patch)
      select.addEventListener("change", function () {
        // sometimes the app expects specific strings; store the mode globally
        if (this.value === "amplified") window.__SLOWROADS_MODE = "amplified";
        else window.__SLOWROADS_MODE = this.value;
      }, { passive: true });
    } catch (e) {
      console.warn("Amplified option insertion failed:", e);
    }
  }

  // scan #root for <select> elements and add the option (idempotent)
  function scanAndAddOption() {
    const root = document.getElementById("root");
    if (!root) return false;
    const selects = root.querySelectorAll("select");
    if (!selects || selects.length === 0) return false;
    selects.forEach(addAmplifiedOptionToSelect);
    return true;
  }

  // Try to find objects in window that have a heightmap and patch methods on them.
  // We wrap getXZ / getHeight / getHeightAt and also try to patch any
  // Float32Array or Array named 'heights' on discovered heightmap objects.
  function patchHeightAccessors() {
    const patched = new Set();
    const candidates = [];

    // gather plausible roots: window properties (some apps keep core objects on window)
    for (let k in window) {
      try {
        const v = window[k];
        if (!v || typeof v !== "object") continue;
        candidates.push({ key: k, obj: v });
      } catch (e) {}
    }

    // small helper to wrap a method only once
    function wrapIfFunction(obj, name, wrapper) {
      try {
        if (!obj || typeof obj[name] !== "function") return false;
        const marker = "__patched__" + name;
        if (obj[marker]) return false;
        const original = obj[name];
        obj[marker] = original;
        obj[name] = function () {
          try {
            const result = original.apply(this, arguments);
            if (window.__SLOWROADS_MODE === "amplified") {
              // apply amplification to numeric result or arrays
              if (typeof result === "number") return amplifyValue(result);
            }
            return result;
          } catch (err) {
            // if wrapper fails, fall back to original safely
            return original.apply(this, arguments);
          }
        };
        return true;
      } catch (e) {
        return false;
      }
    }

    // Try patching inside an object that looks like the scene or controller
    function tryPatchObject(obj, objKey) {
      if (!obj || patched.has(obj)) return false;
      // the built app uses names like 'heightmap' extensively; patch that
      const hm = obj.heightmap || obj.h || (obj.scene && obj.scene.heightmap);
      let did = false;

      if (hm && typeof hm === "object") {
        // patch common functions: getXZ, getHeightAt, getHeight, getXZLayer
        ["getXZ", "getHeight", "getHeightAt", "getXZLayer"].forEach(fnName => {
          if (wrapIfFunction(hm, fnName)) {
            did = true;
          }
        });

        // patch any "heights" array by wrapping accessors that read it:
        if (Array.isArray(hm.heights) || (hm.heights && typeof hm.heights === "object")) {
          // we won't mutate the array directly; instead, create a proxied getter if possible
          try {
            // If the code reads hm.heights directly, we can replace it with a Proxy that yields amplified values on numeric index lookups.
            const arr = hm.heights;
            if (!arr.__isAmplProxy) {
              const proxy = new Proxy(arr, {
                get(target, prop) {
                  // numeric index access -> amplify numeric values
                  if (typeof prop === "string" && /^\d+$/.test(prop)) {
                    const val = Number(target[prop]);
                    if (!isFinite(val)) return val;
                    return (window.__SLOWROADS_MODE === "amplified") ? amplifyValue(val) : val;
                  }
                  // otherwise forward
                  return target[prop];
                }
              });
              proxy.__isAmplProxy = true;
              try { hm.heights = proxy; did = true; } catch (e) {
                // assignment might be blocked; fallback: leave original
              }
            }
          } catch (e) { /* ignore */ }
        }

        patched.add(hm);
      }

      // sometimes the object itself exposes getHeight/getXZ methods (e.g. nearGrid/farGrid)
      ["getXZ", "getHeight", "getHeightAt"].forEach(fn => {
        if (wrapIfFunction(obj, fn)) did = true;
      });

      if (did) {
        console.info("Amplified-mode patch applied to object:", objKey || obj);
        return true;
      }
      return false;
    }

    // First attempt: try patching some obvious global names if present
    const knownNames = ["scene", "game", "app", "world", "heightmap", "nearGrid", "farGrid", "roadController"];
    for (let name of knownNames) {
      try {
        if (window[name] && typeof window[name] === "object") {
          tryPatchObject(window[name], name);
        }
      } catch (e) {}
    }

    // fall back: iterate candidate window objects
    for (let c of candidates) {
      try {
        tryPatchObject(c.obj, c.key);
      } catch (e) {}
    }

    return patched.size > 0;
  }

  // Repeatedly try to inject option and to patch heightmap until success (or until timeout)
  let tries = 0;
  const MAX_TRIES = 60; // ~60 * 500ms = 30s of attempts

  const intervalId = setInterval(() => {
    tries++;
    // add UI option if possible
    try { scanAndAddOption(); } catch (e) {}

    // patch runtime accessors if present
    try {
      const ok = patchHeightAccessors();
      if (ok) {
        // if patched, keep the option available but we can stop retrying patch step
        // let it run a couple more times so things settle, then clear
        if (tries > 6) {
          clearInterval(intervalId);
          console.info("Amplified-mode runtime patch: patching done.");
        }
      } else if (tries >= MAX_TRIES) {
        clearInterval(intervalId);
        console.warn("Amplified-mode runtime patch: could not find patch targets (tried for ~30s).");
      }
    } catch (err) {
      if (tries >= MAX_TRIES) {
        clearInterval(intervalId);
        console.warn("Amplified-mode runtime patch error:", err);
      }
    }
  }, 500);

  // expose helper on window to run a forced manual patch from console if needed
  window.__applyAmplifiedPatch = function () {
    try { scanAndAddOption(); } catch (e) {}
    return patchHeightAccessors();
  };
})();
</script>
  <noscript>You need to enable JavaScript to run this app.</noscript><div id="root"></div><script>!function(e){function r(r){for(var n,a,i=r[0],c=r[1],l=r[2],f=0,p=[];f<i.length;f++)a=i[f],Object.prototype.hasOwnProperty.call(o,a)&&o[a]&&p.push(o[a][0]),o[a]=0;for(n in c)Object.prototype.hasOwnProperty.call(c,n)&&(e[n]=c[n]);for(s&&s(r);p.length;)p.shift()();return u.push.apply(u,l||[]),t()}function t(){for(var e,r=0;r<u.length;r++){for(var t=u[r],n=!0,i=1;i<t.length;i++){var c=t[i];0!==o[c]&&(n=!1)}n&&(u.splice(r--,1),e=a(a.s=t[0]))}return e}var n={},o={1:0},u=[];function a(r){if(n[r])return n[r].exports;var t=n[r]={i:r,l:!1,exports:{}};return e[r].call(t.exports,t,t.exports,a),t.l=!0,t.exports}a.e=function(e){var r=[],t=o[e];if(0!==t)if(t)r.push(t[2]);else{var n=new Promise((function(r,n){t=o[e]=[r,n]}));r.push(t[2]=n);var u,i=document.createElement("script");i.charset="utf-8",i.timeout=120,a.nc&&i.setAttribute("nonce",a.nc),i.src=function(e){return a.p+"static/js/"+({}[e]||e)+"."+{3:"37460af1"}[e]+".chunk.js"}(e);var c=new Error;u=function(r){i.onerror=i.onload=null,clearTimeout(l);var t=o[e];if(0!==t){if(t){var n=r&&("load"===r.type?"missing":r.type),u=r&&r.target&&r.target.src;c.message="Loading chunk "+e+" failed.\n("+n+": "+u+")",c.name="ChunkLoadError",c.type=n,c.request=u,t[1](c)}o[e]=void 0}};var l=setTimeout((function(){u({type:"timeout",target:i})}),12e4);i.onerror=i.onload=u,document.head.appendChild(i)}return Promise.all(r)},a.m=e,a.c=n,a.d=function(e,r,t){a.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:t})},a.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},a.t=function(e,r){if(1&r&&(e=a(e)),8&r)return e;if(4&r&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(a.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var n in e)a.d(t,n,function(r){return e[r]}.bind(null,n));return t},a.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return a.d(r,"a",r),r},a.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},a.p="./",a.oe=function(e){throw console.error(e),e};var i=this["webpackJsonpslowroads.io"]=this["webpackJsonpslowroads.io"]||[],c=i.push.bind(i);i.push=r,i=i.slice();for(var l=0;l<i.length;l++)r(i[l]);var s=c;t()}([])</script><script src="./static/js/2.feea8a5f.chunk.js"></script><script src="./static/js/main.ca6b3355.chunk.js"></script></body></html>
